<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>ProgressivePong — Faster Escalation + New Mechanics</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { color-scheme: dark; }
  html, body { margin:0; height:100%; background:#000; font-family: system-ui, Arial, sans-serif; }
  #ui { position:fixed; inset:0; pointer-events:none; }
  .hud { position:absolute; left:0; right:0; top:0; padding:8px 12px; color:#fff; display:flex; gap:16px; align-items:center; font-weight:600; user-select:none; pointer-events:none; z-index:3; }
  .hud span { opacity:.9 }
  .hud .right { margin-left:auto; text-align:right; font-weight:500; opacity:.9; }
  .btn { pointer-events:auto; cursor:pointer; background:#111; color:#fff; border:2px solid #333; padding:10px 14px; border-radius:10px; font-weight:700; text-align:center; transition:.15s transform, .15s background; }
  .btn:hover { background:#181818; transform:translateY(-1px); }
  .menu { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:10; }
  .card { background:#0b0b0b; border:1px solid #222; border-radius:16px; padding:24px; width:min(92vw, 900px); box-shadow: 0 10px 30px rgba(0,0,0,.35); color:#fff; }
  .title { font-size: clamp(28px, 5vw, 48px); font-weight:900; margin:0 0 8px; letter-spacing:.5px; }
  .subtitle { margin:0 0 18px; opacity:.8; }
  .row { display:flex; flex-wrap:wrap; gap:12px; }
  .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(64px,1fr)); gap:8px; max-height:50vh; overflow:auto; }
  .chip { padding:8px 10px; border:1px solid #333; border-radius:999px; background:#121212; }
  .pill { font-size:12px; opacity:.8; }
  canvas { display:block; width:100vw; height:100vh; background:#0a0a0a; }
  /* Mobile controls */
  .touch-zone { position:absolute; bottom:14px; left:14px; width:36vw; max-width:360px; height:40vh; max-height:260px; border:1px dashed #333; border-radius:16px; color:#bbb; display:flex; align-items:center; justify-content:center; pointer-events:none; user-select:none; z-index:2; }
  .touch-tip { position:absolute; bottom:16px; right:16px; font-size:12px; color:#aaa; z-index:2; }
  .touch-buttons { position:absolute; bottom:14px; right:14px; display:flex; gap:12px; z-index:2; }
  .touch-btn { pointer-events:auto; width:84px; height:84px; border-radius:14px; background:#131313; border:1px solid #333; color:#eee; display:flex; align-items:center; justify-content:center; font-weight:800; font-size:18px; }
  .hidden { display:none !important; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div class="hud" id="hud">
    <span>Level <b id="lvl">1</b>/150</span>
    <span>Round <b id="ps">0</b> - <b id="as">0</b> (first to 5)</span>
    <span>Balls <b id="bc">1</b></span>
    <span class="right" id="msg">Faster escalation on. New mechanic every 2 levels + extra effects.</span>
  </div>
  <div class="menu" id="menu">
    <div class="card">
      <h1 class="title">ProgressivePong</h1>
      <p class="subtitle">First to 5 wins. 150 levels. Early AI nerfed. Level select. Mobile controls. Now faster and weirder.</p>
      <div class="row" style="margin-bottom:16px">
        <div class="btn" id="playBtn">Play</div>
        <div class="btn" id="levelBtn">Level Select</div>
        <div class="btn" id="settingsBtn">Settings</div>
        <div class="btn" id="howBtn">How to Play</div>
      </div>
      <div class="pill">Progress saved locally. Highest unlocked level: <b id="unlockText">1</b></div>
    </div>
  </div>
  <div class="menu hidden" id="levelMenu">
    <div class="card">
      <h2 class="title" style="font-size:28px">Select Level</h2>
      <p class="subtitle">Pick any level up to your highest unlocked. Drag zone is disabled here.</p>
      <div class="grid" id="levelGrid"></div>
      <div class="row" style="margin-top:14px"><div class="btn" id="backFromLevels">Back</div></div>
    </div>
  </div>
  <div class="menu hidden" id="settingsMenu">
    <div class="card">
      <h2 class="title" style="font-size:28px">Settings</h2>
      <div class="row" style="margin-bottom:10px">
        <div class="chip"><label><input type="checkbox" id="sfxToggle"> SFX</label></div>
        <div class="chip"><label><input type="checkbox" id="flashToggle" checked> Visual flashes</label></div>
        <div class="chip"><label><input type="checkbox" id="particlesToggle" checked> Particles</label></div>
        <div class="chip"><label><input type="checkbox" id="mobileDrag" checked> Mobile drag zone</label></div>
        <div class="chip"><label><input type="checkbox" id="mobileButtons"> Mobile up/down buttons</label></div>
      </div>
      <div class="row" style="margin-bottom:10px">
        <div class="chip">Difficulty: <select id="diffSel"><option value="0">Normal</option><option value="1">Hard</option><option value="2">Insane</option></select></div>
        <div class="chip"><button class="btn" id="fsBtn">Toggle Fullscreen</button></div>
        <div class="chip"><button class="btn" id="wipeBtn">Reset Progress</button></div>
      </div>
      <div class="row"><div class="btn" id="backFromSettings">Back</div></div>
    </div>
  </div>
  <div class="menu hidden" id="howMenu">
    <div class="card">
      <h2 class="title" style="font-size:28px">How to Play</h2>
      <ul>
        <li>PC: Arrow keys or W/S to move. P to pause. Space to pulse reflect when unlocked.</li>
        <li>Mobile: Drag zone or buttons. Drag is nerfed and only enabled while playing.</li>
        <li>Level clears when <b>you</b> reach 5. If AI reaches 5 the round restarts at the same level.</li>
      </ul>
      <div class="row"><div class="btn" id="backFromHow">Back</div></div>
    </div>
  </div>
  <!-- Mobile controls -->
  <div class="touch-zone hidden" id="dragZone">Drag to move</div>
  <div class="touch-buttons hidden" id="touchButtons">
    <div class="touch-btn" id="btnUp">▲</div>
    <div class="touch-btn" id="btnDown">▼</div>
  </div>
  <div class="touch-tip" id="touchTip">Mobile: enable controls in Settings</div>
</div>
<script>
(() => {
  // ====== Canvas ======
  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d');
  function resize(){ cvs.width = innerWidth; cvs.height = innerHeight; }
  addEventListener('resize', resize); resize();
  const W = () => cvs.width, H = () => cvs.height;

  // ====== UI ======
  const $ = id => document.getElementById(id);
  const hud = $('hud'), menu = $('menu'), levelMenu = $('levelMenu'), settingsMenu = $('settingsMenu'), howMenu = $('howMenu');
  const msgEl = $('msg'), lvlEl = $('lvl'), psEl = $('ps'), asEl = $('as'), bcEl = $('bc'), unlockText = $('unlockText');
  const playBtn = $('playBtn'), levelBtn = $('levelBtn'), settingsBtn = $('settingsBtn'), howBtn = $('howBtn');
  const backFromLevels = $('backFromLevels'), backFromSettings = $('backFromSettings'), backFromHow = $('backFromHow');
  const fsBtn = $('fsBtn'), wipeBtn = $('wipeBtn');
  const sfxToggle = $('sfxToggle'), flashToggle = $('flashToggle'), particlesToggle = $('particlesToggle');
  const mobileDrag = $('mobileDrag'), mobileButtons = $('mobileButtons');
  const diffSel = $('diffSel');
  const dragZone = $('dragZone'), touchButtons = $('touchButtons'), btnUp = $('btnUp'), btnDown = $('btnDown'), touchTip = $('touchTip');

  // ====== Game state placed early to avoid TDZ ======
  let state = 'menu'; // menu, level, settings, how, playing, paused
  let lvl = 1; const MAX_LEVEL=150;
  let pScore=0, aScore=0; let highestReached=1;

  // ====== Persistence ======
  const store = {
    get k(){ return 'PPONG_SAVE_V5_FAST_COOL'; },
    load(){ try{ return JSON.parse(localStorage.getItem(this.k)||'{}'); }catch{ return {}; } },
    save(data){ localStorage.setItem(this.k, JSON.stringify(data)); }
  };
  const save = store.load();
  let highest = Math.max(1, save.highest||1);
  unlockText.textContent = highest;

  // ====== Input ======
  const keys = Object.create(null);
  addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(state==='playing' && e.key==='p') togglePause(); });
  addEventListener('keyup',   e => keys[e.key.toLowerCase()] = false);

  // Touch drag control (nerfed and disabled outside gameplay)
  let dragActive = false, dragId = null, dragTargetY = null;
  function updateMobileVisibility(){
    const playing = state==='playing';
    const showDrag = playing && mobileDrag.checked;
    const showBtns = playing && mobileButtons.checked;
    dragZone.classList.toggle('hidden', !showDrag);
    touchButtons.classList.toggle('hidden', !showBtns);
    dragZone.style.pointerEvents = showDrag ? 'auto' : 'none';
    touchButtons.style.pointerEvents = showBtns ? 'auto' : 'none';
    touchTip.classList.toggle('hidden', showDrag || showBtns);
  }
  updateMobileVisibility();

  dragZone.addEventListener('pointerdown', e=>{ if(dragZone.style.pointerEvents!=='auto') return; dragActive=true; dragId=e.pointerId; dragZone.setPointerCapture(dragId); dragTargetY = e.clientY; });
  dragZone.addEventListener('pointerup',   ()=>{ dragActive=false; dragId=null; dragTargetY=null; });
  dragZone.addEventListener('pointermove', e=>{ if(!dragActive) return; dragTargetY = e.clientY; });

  // Button controls
  let btnInterval=null;
  function hold(btn, dir){ btn.onpointerdown=()=>{ clearInterval(btnInterval); btnInterval=setInterval(()=>{ player.y = clamp(player.y + dir*playerSpeed()*0.85*16/1000*60, player.h/2, H()-player.h/2); }, 16); };
    btn.onpointerup=btn.onpointerleave=()=>{ clearInterval(btnInterval); };
  }
  hold(btnUp,-1); hold(btnDown,1);

  // Settings
  sfxToggle.checked = !!save.sfx; flashToggle.checked = save.flash!==false; particlesToggle.checked = save.particles!==false;
  mobileDrag.checked = save.mobileDrag!==false; mobileButtons.checked = !!save.mobileButtons;
  diffSel.value = String(save.diff||0);
  ;[sfxToggle,flashToggle,particlesToggle,mobileDrag,mobileButtons,diffSel].forEach(el=> el.addEventListener('change', ()=>{
    store.save({ highest, sfx:sfxToggle.checked, flash:flashToggle.checked, particles:particlesToggle.checked, mobileDrag:mobileDrag.checked, mobileButtons:mobileButtons.checked, diff:+diffSel.value });
    updateMobileVisibility();
  }));

  fsBtn.onclick = () => { if (document.fullscreenElement) document.exitFullscreen(); else document.body.requestFullscreen(); };
  wipeBtn.onclick = () => { highest = 1; store.save({ highest }); unlockText.textContent = highest; };

  // ====== Game Objects ======
  function paddle(x){ return { x, y:H()/2, w:14, h:Math.max(76, H()*0.14), vy:0, dash:0, prev:[] }; }
  const player = paddle(28);
  const ai = paddle(() => W()-28);

  function makeBall(speed=8, dir=1){
    const ang = (Math.random()*Math.PI/2 - Math.PI/4);
    return { x:W()/2, y:H()/2, r:9, vx:Math.cos(ang)*speed*dir, vy:Math.sin(ang)*speed, cooldown:0, stuck:false, prev:[], type:'normal', age:0, gateCD:0 };
  }
  const balls = [ makeBall() ];

  // Speeds and pacing
  function playerSpeed(){ const base = 560; return base * (1 + lvl*0.014); }

  // AI brain with reaction lag, aim noise, and speed cap that scale by level and difficulty
  let aiThinkTimer = 0, aiTargetY = H()/2;
  function aiParams(){
    const diff = +diffSel.value;
    const followBase = 0.06 + lvl*0.0012 + diff*0.01; // low at early levels
    const think = Math.max(0.22 - lvl*0.0017 - diff*0.05, 0.03);
    const noise = Math.max(28 - lvl*0.65 - diff*6, 2);
    const maxVel = 440 + lvl*14 + diff*240; // cap absolute speed
    return { followBase, think, noise, maxVel };
  }

  // Round rule
  const WIN_POINTS = 5;

  // World effects and obstacles
  const fx = {
    invert:false, trail:false, warp:false, bulletTime:false, spin:false, sticky:false, glitch:false,
    gravity:0, windX:0, bandWind:false, conveyor:false, flashes:false,
    angleFactor:0.36, speedMul:1, randReverse:false, paddleMomentum:false,
    pulseReflect:false, shieldL:0, shieldR:0,
    wells:[], bumpers:[], barriers:[], lasers:[], portals:null, collectibles:[], bandY:[],
    // new toys
    arenaShrink:0, speedGates:[], magnet:false, spinZones:[], illusions:0, blackout:false, movingNet:false, paddleGhost:false, pulseBall:false, windOsc:false
  };

  // Utilities
  const clamp = (v,a,b)=>v<a?a:v>b?b:v;
  const rand = (a,b)=>a + Math.random()*(b-a);
  function reflectCircle(ball, cx, cy){ const dx = ball.x - cx, dy = ball.y - cy; const d = Math.hypot(dx,dy)||1; const nx=dx/d, ny=dy/d; const dot = ball.vx*nx+ball.vy*ny; ball.vx -= 2*dot*nx; ball.vy -= 2*dot*ny; }

  // Particles (lightweight)
  const parts = [];
  function spawnBurst(x,y,n=10){ if(!particlesToggle.checked) return; for(let i=0;i<n;i++) parts.push({x,y,vx:rand(-2,2),vy:rand(-2,2),a:1,r:rand(1,3)}); }

  // ====== Mechanics ======
  // Applied at levels 2,4,...; we also escalate baseline speed more aggressively
  const mech = [
    ['Afterimage trails', ()=> fx.trail = true],
    ['Curve bounces by paddle motion', ()=> fx.spin = true],
    ['Gravity wells (corners)', ()=> fx.wells = [ {x:W()*0.2,y:H()*0.2,strength:18,r:120}, {x:W()*0.8,y:H()*0.8,strength:18,r:120} ]],
    ['Center bumper', ()=> fx.bumpers.push({x:W()/2,y:H()/2,r:18})],
    ['Sweeping laser', ()=> fx.lasers.push({x:W()/2-6,y:H()/2-140,w:12,h:280,vx:3,vy:0,on:true,toggle:0,period:1.2})],
    ['Portals appear', ()=> fx.portals=[{x:W()*0.25,y:H()*0.25,r:22},{x:W()*0.75,y:H()*0.75,r:22}]],
    ['Band wind', ()=> { fx.bandWind=true; fx.bandY=[{y0:H()*0.25,y1:H()*0.45,vx:.05},{y0:H()*0.55,y1:H()*0.75,vx:-.05}]; }],
    ['Sticky paddles', ()=> fx.sticky = true],
    ['Random reverse on hit', ()=> fx.randReverse = true],
    ['Bullet-time near paddle', ()=> fx.bulletTime = true],
    ['Conveyor floor', ()=> fx.conveyor = true],
    ['Shield left', ()=> fx.shieldL = 1],
    ['Shield right', ()=> fx.shieldR = 1],
    ['Glitch rendering', ()=> fx.glitch = true],
    ['Extra portals', ()=> fx.portals=[{x:W()*0.25,y:H()*0.75,r:22},{x:W()*0.75,y:H()*0.25,r:22}]],
    ['Paddle momentum', ()=> fx.paddleMomentum = true],
    ['Laser pair', ()=> { fx.lasers.push({x:W()*0.3,y:40,w:W()*0.4,h:10,vx:0,vy:0,on:true,toggle:0,period:0.6}); }],
    ['Moving barriers', ()=> fx.barriers.push({x:W()/2-10,y:H()/2-120,w:20,h:240,vx:2,vy:0})],
    ['Collectible stars → enlarge paddle', ()=> spawnCollectible()],
    ['One-way portals', ()=> fx.portals=[{x:W()*0.2,y:H()*0.2,r:18,one:1},{x:W()*0.8,y:H()*0.8,r:18,one:-1}]],
    ['Warp edges', ()=> fx.warp = true],
    ['Gravity +', ()=> fx.gravity += 0.03],
    ['Wind +', ()=> fx.windX += 0.06],
    ['Extra ball', ()=> balls.push(makeBall(9, Math.random()<0.5?-1:1))],
    ['Dash charge for player', ()=> player.dash = 1],
    ['Bumper set', ()=> { fx.bumpers.push({x:W()*0.35,y:H()*0.35,r:14}); fx.bumpers.push({x:W()*0.65,y:H()*0.65,r:14}); }],
    ['Laser toggles faster', ()=> fx.lasers.forEach(l=>{l.period=Math.max(0.28,l.period*0.7)} )],
    ['More wells', ()=> fx.wells.push({x:W()*0.5,y:H()*0.25,strength:16,r:100}, {x:W()*0.5,y:H()*0.75,strength:16,r:100})],
    ['Portals rotate', ()=> portalsRotate = true],
    ['Split on wall hit', ()=> splitOnWall = true],
    ['Pulse reflect (Space/Tap)', ()=> fx.pulseReflect = true],
    ['Bigger ball type appears', ()=> balls.forEach(b=> b.type='heavy')],
    ['Shrink paddle edges', ()=> { player.h*=0.9; ai.h*=0.9; }],
    ['Extra barriers', ()=> fx.barriers.push({x:W()/2-200,y:H()/2-80,w:18,h:160,vx:2.6,vy:0})],
    ['Faster AI', ()=> aiSpeedBoost+=0.02],
    ['Double collectibles', ()=> spawnCollectible(2)],
    ['Laser wall center', ()=> fx.lasers.push({x:W()/2-2,y:0,w:4,h:H(),vx:0,vy:0,on:true,toggle:0,period:0.9})],
    ['Angle factor ++', ()=> fx.angleFactor += 0.06],
    ['Reverse controls', ()=> fx.invert = true],
    ['Conveyor bands ++', ()=> fx.bandY.push({y0:H()*0.1,y1:H()*0.2,vx:.06},{y0:H()*0.8,y1:H()*0.9,vx:-.06})],
    ['Chaos bumper', ()=> fx.bumpers.push({x:W()*0.5,y:H()*0.5,r:26})],
    ['Rapid toggling shields', ()=> { fx.shieldL = 2; fx.shieldR = 2; }],
    ['Velocity jitter', ()=> velJitter = true],
    ['Ball spawns with spin', ()=> spawnWithSpin = true],
    ['Thin paddles', ()=> { player.w=10; ai.w=10; }],
    ['Fat paddles', ()=> { player.w+=6; ai.w+=6; }],
    ['Edge portals', ()=> fx.portals=[{x:W()*0.1,y:H()*0.5,r:22},{x:W()*0.9,y:H()*0.5,r:22}]],
    ['Laser rain', ()=> { for(let i=0;i<4;i++) fx.lasers.push({x:rand(0,W()-8),y:rand(0,H()-120),w:8,h:120,vx:rand(-2,2),vy:0,on:true,toggle:0,period:1}); }],
    ['Final speed surge', ()=> baseSpeedMul *= 1.25],
    // Newer and weirder
    ['Arena shrink', ()=> fx.arenaShrink = Math.min(80, fx.arenaShrink + 40)],
    ['Speed gates', ()=> fx.speedGates.push({x:W()*0.35,y:H()*0.3,w:16,h:140,mul:1.18},{x:W()*0.65,y:H()*0.55,w:16,h:140,mul:1.18})],
    ['Magnet paddles', ()=> fx.magnet = true],
    ['Spin zones', ()=> fx.spinZones.push({x:W()*0.5,y:H()*0.3,r:60,t:1},{x:W()*0.5,y:H()*0.7,r:60,t:-1})],
    ['Illusion clones', ()=> fx.illusions = Math.min(4, (fx.illusions||0)+2)],
    ['Blackout flicker', ()=> fx.blackout = true],
    ['Moving net', ()=> fx.movingNet = true],
    ['Paddle afterimages', ()=> fx.paddleGhost = true],
    ['Wind oscillation', ()=> fx.windOsc = true],
    ['Homing laser', ()=> fx.lasers.push({x:W()-14,y:0,w:8,h:200,vx:0,vy:0,on:true,toggle:0,period:1,homing:true})],
    ['Arena shrink ++', ()=> fx.arenaShrink = Math.min(120, fx.arenaShrink + 20)],
    ['More speed gates', ()=> fx.speedGates.push({x:W()*0.25,y:H()*0.2,w:12,h:120,mul:1.15},{x:W()*0.75,y:H()*0.6,w:12,h:120,mul:1.15})],
    ['Triple portals', ()=> fx.portals=[{x:W()*0.25,y:H()*0.25,r:18},{x:W()*0.75,y:H()*0.25,r:18},{x:W()*0.5,y:H()*0.75,r:18}]],
    ['Pulse-ball visuals', ()=> fx.pulseBall = true],
    ['Moving bumpers', ()=> fx.bumpers.push({x:W()*0.3,y:H()*0.5,r:18,vx:2},{x:W()*0.7,y:H()*0.5,r:18,vx:-2})],
    ['Extra wells grid', ()=> { for(let i=0;i<3;i++) fx.wells.push({x:rand(W()*0.25,W()*0.75), y:rand(H()*0.25,H()*0.75), strength:12, r:80}); }],
    ['Portal chaos', ()=> fx.portals=[{x:W()*0.2,y:H()*0.2,r:18},{x:W()*0.8,y:H()*0.2,r:18},{x:W()*0.2,y:H()*0.8,r:18},{x:W()*0.8,y:H()*0.8,r:18}]],
    ['Split on paddle', ()=> splitOnPaddle = true],
    ['Gate boost ++', ()=> fx.speedGates.forEach(g=> g.mul+=0.05)],
    ['Magnet stronger', ()=> fx.magnet = true]
  ];

  // Flags for secondary mechanics and escalation
  let portalsRotate=false, splitOnWall=false, splitOnPaddle=false, velJitter=false, spawnWithSpin=false, baseSpeedMul=1.12, aiSpeedBoost=0;

  function spawnCollectible(n=1){ for(let i=0;i<n;i++) fx.collectibles.push({x:rand(W()*0.3,W()*0.7), y:rand(H()*0.2,H()*0.8), r:10, ttl:8}); }

  // Menus
  function show(el){ [menu, levelMenu, settingsMenu, howMenu].forEach(e=> e.classList.add('hidden')); el.classList.remove('hidden'); updateMobileVisibility(); }
  playBtn.onclick = ()=>{ beginGame(lvl); };
  levelBtn.onclick = ()=>{ buildLevelGrid(); show(levelMenu); state='level'; };
  settingsBtn.onclick = ()=>{ show(settingsMenu); state='settings'; };
  howBtn.onclick = ()=>{ show(howMenu); state='how'; };
  backFromLevels.onclick = ()=>{ show(menu); state='menu'; };
  backFromSettings.onclick = ()=>{ show(menu); state='menu'; };
  backFromHow.onclick = ()=>{ show(menu); state='menu'; };

  function buildLevelGrid(){ const g = $('levelGrid'); g.innerHTML=''; for(let i=1;i<=MAX_LEVEL;i++){ const d=document.createElement('div'); d.className='btn'; d.textContent=String(i); if(i>highest){ d.style.opacity=.35; d.style.cursor='not-allowed'; } else { d.onclick=()=>{ lvl=i; show(menu); state='menu'; beginGame(lvl); }; } g.appendChild(d); } }

  function clearWorld(){ balls.length=0; balls.push(makeBall()); pScore=0; aScore=0; aiThinkTimer=0; aiTargetY=H()/2; }

  function beginGame(fromLevel){
    // Reset world
    clearWorld();
    lvl = Math.max(1, Math.min(MAX_LEVEL, fromLevel||1));
    // reset effects
    fx.wells=[]; fx.bumpers=[]; fx.barriers=[]; fx.lasers=[]; fx.portals=null; fx.collectibles=[]; fx.bandY=[]; fx.speedGates=[]; fx.spinZones=[]; fx.arenaShrink=0; fx.illusions=0; fx.blackout=false; fx.movingNet=false; fx.paddleGhost=false; fx.pulseBall=false; fx.magnet=false; fx.windOsc=false;
    Object.assign(fx, { invert:false, trail:false, warp:false, bulletTime:false, spin:false, sticky:false, glitch:false, gravity:0, windX:0, bandWind:false, conveyor:false, flashes:false, angleFactor:0.36, speedMul:1, randReverse:false, paddleMomentum:false, pulseReflect:false, shieldL:0, shieldR:0 });
    portalsRotate=false; splitOnWall=false; splitOnPaddle=false; velJitter=false; spawnWithSpin=false; baseSpeedMul=1.12; aiSpeedBoost=0;

    // Start AI slightly worse than player at low levels
    ai.h = Math.max(60, player.h*0.85);

    // Apply mechanics up to current level
    for(let L=2; L<=Math.min(lvl, mech.length*2); L+=2){ const idx=(L/2)-1; if(mech[idx]) mech[idx][1](); }
    // Escalate beyond designed mechanics
    if(lvl>mech.length*2){ for(let L=mech.length*2+2; L<=lvl; L+=2){ escalate(L); } }

    hud.style.display='flex'; [menu, levelMenu, settingsMenu, howMenu].forEach(e=> e.classList.add('hidden'));
    state='playing'; updateMobileVisibility();
    msgEl.textContent = `Level ${lvl}. First to ${WIN_POINTS}.`;
  }

  function escalate(L){ // stronger escalation
    baseSpeedMul *= 1.06; // faster balls
    aiSpeedBoost += 0.012; // smarter AI
    if(L % 8 === 0) fx.barriers.push({x:rand(120,W()-140), y:rand(100,H()-220), w:16, h:180, vx:rand(-2.5,2.5), vy:0});
    if(L % 12 === 0) balls.push(makeBall(9+L*0.01, Math.random()<0.5?-1:1));
    if(L % 16 === 0) fx.wells.push({x:rand(W()*0.2,W()*0.8), y:rand(H()*0.2,H()*0.8), strength:14, r:90});
  }

  function togglePause(){ if(state==='playing'){ state='paused'; msgEl.textContent='Paused'; updateMobileVisibility(); } else if(state==='paused'){ state='playing'; msgEl.textContent=`Level ${lvl}.`; updateMobileVisibility(); } }

  // Pulse reflect
  addEventListener('keydown', e=>{ if(e.code==='Space' && fx.pulseReflect) doPulse(); });
  cvs.addEventListener('pointerdown', e=>{ if(fx.pulseReflect && e.clientX>W()*0.6 && state==='playing') doPulse(); });
  function doPulse(){ for(const b of balls){ const dx=b.x-player.x, dy=b.y-player.y; const d=Math.hypot(dx,dy); if(d<220){ b.vx += (dx/d||1)*3; b.vy += (dy/d||1)*3; spawnBurst(b.x,b.y,16);} }
    msg('Pulse!'); }

  // Messaging
  function msg(t){ msgEl.textContent=t; }

  // ====== Update ======
  function update(dt){ if(state!=='playing' && state!=='paused') return; if(state==='paused') return;
    const nowms = performance.now();

    // Controls
    const up = keys['arrowup']||keys['w']; const down = keys['arrowdown']||keys['s'];
    let dir = (up?-1:0) + (down?1:0); if(fx.invert) dir*=-1;

    // Nerfed drag: move toward target with capped speed
    if(dragTargetY!=null){ const dy = clamp(dragTargetY, player.h/2+fx.arenaShrink, H()-player.h/2-fx.arenaShrink) - player.y; const maxStep = playerSpeed()*0.75*dt; if(Math.abs(dy) > maxStep) player.y += Math.sign(dy)*maxStep; else player.y += dy; }

    if(player.dash>0 && keys['shift']) player.vy = dir * playerSpeed() * 1.7; else player.vy = dir * playerSpeed();
    player.y = clamp(player.y + player.vy*dt, player.h/2+fx.arenaShrink, H()-player.h/2-fx.arenaShrink);

    // store paddle trail for ghost effect
    player.prev.push(player.y); if(player.prev.length>12) player.prev.shift();
    ai.prev.push(ai.y); if(ai.prev.length>12) ai.prev.shift();

    // AI with think-lag, noise, and capped velocity
    const p = aiParams(); aiThinkTimer -= dt; if(aiThinkTimer<=0){ aiThinkTimer = p.think; const noise=(Math.random()*2-1)*p.noise; aiTargetY = clamp((balls[0]?.y||H()/2) + noise, ai.h/2+fx.arenaShrink, H()-ai.h/2-fx.arenaShrink); }
    const dyAI = aiTargetY - ai.y; const step = Math.sign(dyAI)*Math.min(Math.abs(dyAI), (p.maxVel*(p.followBase+aiSpeedBoost))*dt); ai.y = clamp(ai.y + step, ai.h/2+fx.arenaShrink, H()-ai.h/2-fx.arenaShrink);

    // Move barriers
    fx.barriers.forEach(b=>{ b.x += (b.vx||0); b.y += (b.vy||0); if(b.x<80||b.x+b.w>W()-80) b.vx*=-1; if(b.y<40+fx.arenaShrink||b.y+b.h>H()-40-fx.arenaShrink) b.vy*=-1; });

    // Toggle lasers and homing behavior
    fx.lasers.forEach(l=>{ l.toggle=(l.toggle||0)+dt; if(l.toggle>l.period){ l.on=!l.on; l.toggle=0; }
      if(l.homing){ const targetY = (balls[0]?.y||H()/2)-l.h/2; l.y += (targetY - l.y) * 0.02; }
      l.x += l.vx||0; l.y += l.vy||0; if(l.x<40||l.x+l.w>W()-40) l.vx*=-1; });

    // Rotate portals
    if(portalsRotate && fx.portals){ const t=nowms/800; fx.portals[0].x=W()*0.25 + Math.cos(t)*60; fx.portals[0].y=H()*0.25 + Math.sin(t)*60; if(fx.portals[1]){ fx.portals[1].x=W()*0.75 + Math.cos(-t)*60; fx.portals[1].y=H()*0.75 + Math.sin(-t)*60; } }

    // Wind oscillation
    const windOsc = fx.windOsc ? Math.sin(nowms/700)*0.08 : 0;

    // Collectibles TTL
    fx.collectibles = fx.collectibles.filter(s=> (s.ttl-=dt)>0 );

    // Balls
    for(const b of balls){
      b.age += dt; if(b.cooldown>0) b.cooldown-=dt; if(b.gateCD>0) b.gateCD-=dt;
      // band wind
      if(fx.bandWind){ for(const band of fx.bandY){ if(b.y>band.y0 && b.y<band.y1) b.vx += band.vx; } }
      b.vx += fx.windX + windOsc; b.vy += fx.gravity;
      const speedMul = fx.speedMul * baseSpeedMul * (1 + lvl*0.007);
      let localMul = speedMul;
      if(fx.bulletTime){ const dx = Math.abs(b.x - player.x); if(dx<160) localMul *= 0.7; }

      // Magnet paddles
      if(fx.magnet){ const attr = (pad)=>{ const dx=pad.x - b.x, dy=pad.y - b.y; const d=Math.hypot(dx,dy); if(d<260){ const f=0.02*(1-d/260); b.vx += dx/d*f; b.vy += dy/d*f; } }; attr(player); attr({x: typeof ai.x==='function'? ai.x():ai.x, y:ai.y}); }

      // Spin zones add tangential velocity
      fx.spinZones.forEach(sz=>{ const dx=b.x-sz.x, dy=b.y-sz.y; const d2=dx*dx+dy*dy; if(d2<sz.r*sz.r){ const d=Math.sqrt(d2)||1; const tx = -dy/d*sz.t*0.12, ty = dx/d*sz.t*0.12; b.vx += tx; b.vy += ty; } });

      b.x += b.vx * localMul; b.y += b.vy * localMul;

      // Trails
      if(fx.trail){ b.prev.push([b.x,b.y]); if(b.prev.length>14) b.prev.shift(); }

      // Conveyor floor
      if(fx.conveyor) b.vx += Math.sin(b.y/120)*0.02;

      // Glitch
      if(fx.glitch && Math.random()<0.003){ b.vx*=-1; b.vy+=rand(-1,1); }

      const topB = fx.arenaShrink, botB = H()-fx.arenaShrink;
      // Walls
      if(!fx.warp){
        if(b.y - b.r < topB){ b.y=topB+b.r; b.vy*=-1; hitShake(); if(splitOnWall) trySplit(b); }
        if(b.y + b.r > botB){ b.y=botB-b.r; b.vy*=-1; hitShake(); if(splitOnWall) trySplit(b); }
      } else {
        if(b.y<topB) b.y=botB; if(b.y>botB) b.y=topB; if(b.x<0) b.x=W(); if(b.x>W()) b.x=0;
      }

      // Shields
      if(fx.shieldL){ const sx=60, w=8, y=H()/2-100, h=200; if(rectHit(b,sx,y,w,h)){ b.x=sx+w+b.r; b.vx=Math.abs(b.vx); spawnBurst(b.x,b.y,6); } }
      if(fx.shieldR){ const sx=W()-68, w=8, y=H()/2-100, h=200; if(rectHit(b,sx,y,w,h)){ b.x=sx-b.r; b.vx=-Math.abs(b.vx); spawnBurst(b.x,b.y,6); } }

      // Barriers
      for(const r of fx.barriers){ if(rectHit(b,r.x,r.y,r.w,r.h)) bounceRect(b,r); }

      // Bumpers
      for(const p of fx.bumpers){ const dx=b.x-p.x, dy=b.y-p.y; if(p.vx){ p.x += p.vx; if(p.x-p.r<80||p.x+p.r>W()-80) p.vx*=-1; } const d=Math.hypot(dx,dy); if(d < b.r+p.r){ reflectCircle(b,p.x,p.y); b.x += (dx/(d||1))*(b.r+p.r-d); b.y += (dy/(d||1))*(b.r+p.r-d); hitShake(); } }

      // Wells
      for(const w of fx.wells){ const dx=w.x-b.x, dy=w.y-b.y; const d2=dx*dx+dy*dy; if(d2<w.r*w.r){ const d=Math.sqrt(d2)||1; const f=w.strength/d2; b.vx += (dx/d)*f; b.vy += (dy/d)*f; } }

      // Lasers
      for(const l of fx.lasers){ if(!l.on) continue; if(rectHit(b,l.x,l.y,l.w,l.h)){ b.vx*=-1; b.vy+=rand(-1,1); spawnBurst(b.x,b.y,14); hitShake(); } }

      // Speed gates
      for(const g of fx.speedGates){ if(rectHit(b,g.x,g.y,g.w,g.h) && b.gateCD<=0){ b.vx*=g.mul; b.vy*=g.mul; b.gateCD=0.25; spawnBurst(b.x,b.y,8); } }

      // Portals (supports more than 2 by cycling)
      if(fx.portals && fx.portals.length>=2){ for(let i=0;i<fx.portals.length;i++){ const A=fx.portals[i]; if(circleHit(b,A) && b.cooldown<=0 && (!A.one || Math.sign(b.vx)===A.one)){ const j=(i+1)%fx.portals.length; const B=fx.portals[j]; b.x=B.x; b.y=B.y; b.cooldown=.25; hitShake(); break; } } }

      // Collectibles
      for(let i=fx.collectibles.length-1;i>=0;i--){ const s=fx.collectibles[i]; if(circleHit(b,s)){ fx.collectibles.splice(i,1); player.h = Math.min(H()*0.5, player.h*1.1); msg('Collected: Paddle grow'); spawnBurst(s.x,s.y,18); }}

      // Paddle collisions
      const leftHit = collidePaddle(b, 'left', player);
      const rightHit = collidePaddle(b, 'right', ai);
      if(splitOnPaddle && (leftHit||rightHit)) trySplit(b);

      // Scoring → first to 5
      if(!fx.warp){
        if(b.x + b.r < 0){ if(award('ai')) return; resetBall(b,-1); }
        if(b.x - b.r > W()){ if(award('player')) return; resetBall(b,1); }
      }

      // Velocity jitter
      if(velJitter){ b.vx += rand(-0.02,0.02); b.vy += rand(-0.02,0.02); }
    }

    // Particles decay
    for(let i=parts.length-1;i>=0;i--){ const p=parts[i]; p.x+=p.vx; p.y+=p.vy; p.a-=0.02; if(p.a<=0) parts.splice(i,1); }

    // HUD and progress
    lvlEl.textContent = lvl; psEl.textContent = pScore; asEl.textContent = aScore; bcEl.textContent = balls.length;
    if(highestReached>highest){ highest = highestReached; unlockText.textContent = highest; store.save({ highest, sfx:sfxToggle.checked, flash:flashToggle.checked, particles:particlesToggle.checked, mobileDrag:mobileDrag.checked, mobileButtons:mobileButtons.checked, diff:+diffSel.value }); }
  }

  function award(side){ if(side==='player') pScore++; else aScore++; if(pScore>=WIN_POINTS){ advanceLevel(); return true; } if(aScore>=WIN_POINTS){ failRound(); return true; } return false; }

  function advanceLevel(){ lvl = Math.min(MAX_LEVEL, lvl+1); highestReached = Math.max(highestReached, lvl);
    if(lvl%2===0){ const idx=(lvl/2)-1; const m=mech[idx]; if(m){ m[1](); msg(`Lv ${lvl}: ${m[0]}`); } else { escalate(lvl); msg(`Lv ${lvl}: escalation`); } }
    clearWorld(); msg(`Level up → ${lvl}`); }

  function failRound(){ msg('Round lost. Try again.'); clearWorld(); }

  function trySplit(b){ if(balls.length<6){ const nb = makeBall(Math.hypot(b.vx,b.vy), Math.sign(-b.vx)||1); nb.x=b.x; nb.y=b.y; nb.vx=-b.vx*0.9; nb.vy=b.vy*0.9; balls.push(nb); }}

  function rectHit(b,x,y,w,h){ return b.x + b.r > x && b.x - b.r < x+w && b.y + b.r > y && b.y - b.r < y+h; }
  function circleHit(b,c){ const dx=b.x-c.x, dy=b.y-c.y; return dx*dx+dy*dy < (b.r+c.r)*(b.r+c.r); }
  function bounceRect(b,r){ const leftPen = Math.abs(r.x - (b.x + b.r)); const rightPen = Math.abs((r.x + r.w) - (b.x - b.r)); if (leftPen < rightPen) { b.x = r.x - b.r; b.vx = -Math.abs(b.vx); } else { b.x = r.x + r.w + b.r; b.vx = Math.abs(b.vx); } hitShake(); }

  function collidePaddle(b, side, pad){ const px = typeof pad.x==='function'? pad.x(): pad.x; const py = pad.y; const pw = pad.w, ph = pad.h; const rx = px - pw/2, ry = py - ph/2; if(rectHit(b, rx, ry, pw, ph)){
      const center = py; const off = (b.y - center)/(ph/2); const ang = clamp(off,-1,1) * fx.angleFactor * Math.PI/2; const sp = Math.max(6, Math.hypot(b.vx,b.vy)); const dir = side==='left'?1:-1;
      b.vx = Math.cos(ang)*sp*dir; b.vy = Math.sin(ang)*sp; if(fx.spin) b.vy += pad.vy*0.05; if(fx.randReverse && Math.random()<0.03) b.vx*=-1;
      if(fx.sticky){ b.stuck=true; setTimeout(()=>{ b.stuck=false; }, 160); }
      spawnBurst(b.x,b.y,10); hitShake();
      return true;
    }
    return false;
  }

  function resetBall(b, dir){ b.x=W()/2; b.y=H()/2; const speed = 8 + lvl*0.12; const ang = (Math.random()*Math.PI/2 - Math.PI/4); b.vx = Math.cos(ang)*speed*dir; b.vy = Math.sin(ang)*speed; b.prev.length=0; if(spawnWithSpin){ b.vy += rand(-1,1); } }

  let shakeT=0; function hitShake(){ shakeT=0.12; }

  // ====== Draw ======
  function draw(){
    // Background
    ctx.fillStyle = '#080808'; ctx.fillRect(0,0,W(),H());

    // Arena shrink bands
    if(fx.arenaShrink>0){ ctx.fillStyle='#111'; ctx.fillRect(0,0,W(),fx.arenaShrink); ctx.fillRect(0,H()-fx.arenaShrink,W(),fx.arenaShrink); }

    ctx.save(); if(shakeT>0){ ctx.translate((Math.random()-.5)*14*shakeT*6,(Math.random()-.5)*14*shakeT*6); shakeT=Math.max(0,shakeT-0.02); }

    // Net (can move)
    const netOffset = fx.movingNet ? Math.sin(performance.now()/600)*30 : 0;
    ctx.fillStyle='#ddd'; for(let y=0;y<H();y+=24) ctx.fillRect(W()/2-2+netOffset,y,4,14);

    // Shields
    if(fx.shieldL){ ctx.fillStyle='#2af'; ctx.fillRect(60, H()/2-100, 8, 200); }
    if(fx.shieldR){ ctx.fillStyle='#2af'; ctx.fillRect(W()-68, H()/2-100, 8, 200); }

    // Barriers
    ctx.fillStyle='#3af'; fx.barriers.forEach(r=> ctx.fillRect(r.x,r.y,r.w,r.h));

    // Lasers
    ctx.fillStyle='#f33'; fx.lasers.forEach(l=>{ if(l.on) ctx.fillRect(l.x,l.y,l.w,l.h); });

    // Bumpers
    ctx.fillStyle='#f47'; fx.bumpers.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); });

    // Spin zones
    ctx.strokeStyle='#6f6'; ctx.lineWidth=2; fx.spinZones.forEach(sz=>{ ctx.beginPath(); ctx.arc(sz.x,sz.y,sz.r,0,Math.PI*2); ctx.stroke(); });

    // Speed gates
    ctx.fillStyle='#49f'; fx.speedGates.forEach(g=> ctx.fillRect(g.x,g.y,g.w,g.h));

    // Portals
    if(fx.portals){ ctx.strokeStyle='#9f9'; ctx.lineWidth=3; fx.portals.forEach(P=>{ ctx.beginPath(); ctx.arc(P.x,P.y,P.r,0,Math.PI*2); ctx.stroke(); }); }

    // Collectibles
    ctx.fillStyle='#ff5'; fx.collectibles.forEach(s=>{ ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); });

    // Paddles + ghost trails
    if(fx.paddleGhost){ ctx.globalAlpha=0.12; ctx.fillStyle='#fff'; for(const [i,py] of player.prev.entries()){ ctx.fillRect(player.x-player.w/2, py-player.h/2, player.w, player.h); } for(const [i,py] of ai.prev.entries()){ const aix = typeof ai.x==='function'? ai.x(): ai.x; ctx.fillRect(aix-ai.w/2, py-ai.h/2, ai.w, ai.h); } ctx.globalAlpha=1; }
    ctx.fillStyle='#fff'; ctx.fillRect(player.x-player.w/2, player.y-player.h/2, player.w, player.h);
    const aix = typeof ai.x==='function'? ai.x(): ai.x; ctx.fillRect(aix-ai.w/2, ai.y-ai.h/2, ai.w, ai.h);

    // Balls + trails + illusions
    for(const b of balls){ if(fx.trail && b.prev.length>1){ ctx.globalAlpha=0.12; for(const [x,y] of b.prev){ ctx.beginPath(); ctx.arc(x,y,Math.max(2,b.r-3),0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); } ctx.globalAlpha=1; }
      const drawBall = (x,y,alpha=1)=>{ ctx.globalAlpha=alpha; ctx.beginPath(); const r = fx.pulseBall? b.r + Math.sin(performance.now()/100 + x*0.01+y*0.01)*1.5 : b.r; ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); ctx.globalAlpha=1; };
      drawBall(b.x,b.y,1);
      for(let i=0;i<(fx.illusions||0);i++){ const offx = Math.cos((i+1)*1.7)*30, offy = Math.sin((i+1)*1.3)*30; drawBall(b.x+offx,b.y+offy,0.2); }
    }

    ctx.restore();

    // Blackout overlay
    if(fx.blackout){ const on = Math.sin(performance.now()/600) > 0.7; if(on){ ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(0,0,W(),H()); } }
  }

  // ====== Main loop ======
  let last = performance.now();
  function frame(now){ const dt = Math.min(0.05,(now-last)/1000); last=now; update(dt); draw(); requestAnimationFrame(frame); }
  requestAnimationFrame(frame);

  // ====== Boot ======
  show(menu); state='menu';
})();
</script>
</body>
</html>
