<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>ProgressivePong ‚Äî 400 Levels ‚Ä¢ Coins ‚Ä¢ Abilities ‚Ä¢ Expanded Mechanics</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { color-scheme: dark; }
  html, body { margin:0; height:100%; background:#000; font-family: system-ui, Arial, sans-serif; }
  #ui { position:fixed; inset:0; pointer-events:none; }
  .hud { position:absolute; left:0; right:0; top:0; padding:8px 12px; color:#fff; display:flex; gap:16px; align-items:center; font-weight:600; user-select:none; pointer-events:none; z-index:3; }
  .hud span { opacity:.9 }
  .hud .right { margin-left:auto; text-align:right; font-weight:500; opacity:.9; display:flex; gap:8px; align-items:center; }
  .btn { pointer-events:auto; cursor:pointer; background:#111; color:#fff; border:2px solid #333; padding:10px 14px; border-radius:10px; font-weight:700; text-align:center; transition:.15s transform, .15s background; }
  .btn:hover { background:#181818; transform:translateY(-1px); }
  .btn.small { padding:6px 10px; border-radius:8px; font-size:12px; }
  .menu { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:auto; z-index:10; }
  .card { background:#0b0b0b; border:1px solid #222; border-radius:16px; padding:24px; width:min(92vw, 1000px); box-shadow: 0 10px 30px rgba(0,0,0,.35); color:#fff; }
  .title { font-size: clamp(28px, 5vw, 48px); font-weight:900; margin:0 0 8px; letter-spacing:.5px; }
  .subtitle { margin:0 0 18px; opacity:.8; }
  .row { display:flex; flex-wrap:wrap; gap:12px; }
  .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(64px,1fr)); gap:8px; max-height:52vh; overflow:auto; }
  .chip { padding:8px 10px; border:1px solid #333; border-radius:999px; background:#121212; }
  .pill { font-size:12px; opacity:.8; }
  canvas { display:block; width:100vw; height:100vh; background:#0a0a0a; }
  /* Mobile controls */
  .touch-zone { position:absolute; bottom:14px; left:14px; width:36vw; max-width:360px; height:40vh; max-height:260px; border:1px dashed #333; border-radius:16px; color:#bbb; display:flex; align-items:center; justify-content:center; pointer-events:none; user-select:none; z-index:2; }
  .touch-tip { position:absolute; bottom:16px; right:16px; font-size:12px; color:#aaa; z-index:2; }
  .touch-buttons { position:absolute; bottom:14px; right:14px; display:flex; gap:12px; z-index:2; }
  .touch-btn { pointer-events:auto; width:84px; height:84px; border-radius:14px; background:#131313; border:1px solid #333; color:#eee; display:flex; align-items:center; justify-content:center; font-weight:800; font-size:18px; }
  .hidden { display:none !important; }
  /* HUD abilities strip */
  .abil { pointer-events:auto; display:flex; gap:6px; }
  .coin { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid #333; border-radius:8px; background:#121212; font-size:12px; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div class="hud" id="hud">
    <span>Level <b id="lvl">1</b>/400</span>
    <span>Round <b id="ps">0</b> - <b id="as">0</b> (first to 5)</span>
    <span>Balls <b id="bc">1</b></span>
    <span class="right">
      <span id="msg">Expanded mechanics + 20 shop items. Readable pacing. Assists only via shop or every 25 levels.</span>
      <span class="coin">üü° <b id="coinCount">0</b></span>
      <button class="btn small" id="shopOpen">Shop</button>
      <button class="btn small" id="lobbyBtn">Lobby</button>
      <span class="abil" id="abilStrip">
        <button class="btn small" id="btnAbilSlow" title="Focus slow (Q)">Q: Slow <span id="slowCt">0</span></button>
        <button class="btn small" id="btnAbilShield" title="Shield (E)">E: Shield <span id="shieldCt">0</span></button>
        <button class="btn small" id="btnAbilFreeze" title="Freeze lasers (F)">F: Freeze <span id="freezeCt">0</span></button>
        <button class="btn small" id="btnAbilPortal" title="Shuffle portals (R)">R: Portals <span id="portalCt">0</span></button>
        <button class="btn small" id="btnAbilBand" title="Flip wind bands (B)">B: Wind <span id="bandCt">0</span></button>
        <button class="btn small" id="btnAbilPulse" title="Pulse reflect (Space)">‚ê£: Pulse</button>
      </span>
    </span>
  </div>

  <div class="menu" id="menu">
    <div class="card">
      <h1 class="title">ProgressivePong</h1>
      <p class="subtitle">400 levels. First to 5. AI ramps but capped vs player. Complexity caps keep it readable. Warp edges disabled.</p>
      <div class="row" style="margin-bottom:16px">
        <div class="btn" id="playBtn">Play</div>
        <div class="btn" id="levelBtn">Level Select</div>
        <div class="btn" id="settingsBtn">Settings</div>
        <div class="btn" id="shopBtn">Shop</div>
        <div class="btn" id="howBtn">How to Play</div>
      </div>
      <div class="pill">Progress saved locally. Highest unlocked: <b id="unlockText">1</b> ‚Ä¢ Coins: <b id="unlockCoins">0</b></div>
    </div>
  </div>

  <div class="menu hidden" id="levelMenu">
    <div class="card">
      <h2 class="title" style="font-size:28px">Select Level</h2>
      <p class="subtitle">Pick any level up to your highest. Drag zone is disabled here.</p>
      <div class="grid" id="levelGrid"></div>
      <div class="row" style="margin-top:14px"><div class="btn" id="backFromLevels">Back</div></div>
    </div>
  </div>

  <div class="menu hidden" id="settingsMenu">
    <div class="card">
      <h2 class="title" style="font-size:28px">Settings</h2>
      <div class="row" style="margin-bottom:10px">
        <div class="chip"><label><input type="checkbox" id="sfxToggle"> SFX</label></div>
        <div class="chip"><label><input type="checkbox" id="flashToggle" checked> Visual flashes</label></div>
        <div class="chip"><label><input type="checkbox" id="particlesToggle" checked> Particles</label></div>
        <div class="chip"><label><input type="checkbox" id="mobileDrag" checked> Mobile drag zone</label></div>
        <div class="chip"><label><input type="checkbox" id="mobileButtons"> Mobile up/down buttons</label></div>
      </div>
      <div class="row" style="margin-bottom:10px">
        <div class="chip"><label><input type="checkbox" id="allowGravity"> Gravity effects</label></div>
        <div class="chip"><label><input type="checkbox" id="allowGlitch"> Glitch jitter</label></div>
      </div>
      <div class="row" style="margin-bottom:10px">
        <div class="chip">Difficulty: <select id="diffSel"><option value="0">Normal</option><option value="1">Hard</option><option value="2">Insane</option></select></div>
        <div class="chip"><button class="btn" id="fsBtn">Toggle Fullscreen</button></div>
        <div class="chip"><button class="btn" id="wipeBtn">Reset Progress</button></div>
      </div>
      <div class="row"><div class="btn" id="backFromSettings">Back</div></div>
    </div>
  </div>

  <div class="menu hidden" id="shopMenu">
    <div class="card">
      <h2 class="title" style="font-size:28px">PongCoins Shop</h2>
      <p class="subtitle">20 items. Charges refresh each round. Balance caps stay on.</p>
      <div id="shopList" class="grid" style="grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));"></div>
      <div class="row" style="margin-top:14px"><div class="btn" id="backFromShop">Back</div></div>
    </div>
  </div>

  <div class="menu hidden" id="howMenu">
    <div class="card">
      <h2 class="title" style="font-size:28px">How to Play</h2>
      <!-- Kindergarten-level text -->
      <p class="subtitle" style="line-height:1.5">
        Move your paddle up and down.<br>
        Hit the ball back. Do not let it go past you.<br>
        First to 5 points wins the level.<br>
        On computer: use the arrow keys or W and S.<br>
        On phone: drag or tap the buttons to move.<br>
        Space makes a push if you have it. Q slows time. E makes a shield.<br>
        F can freeze lasers. R can move portals. B can flip the wind.<br>
        Win levels to earn coins. Buy cool things in the shop.
      </p>
      <div class="row"><div class="btn" id="backFromHow">Back</div></div>
    </div>
  </div>

  <!-- Mobile controls -->
  <div class="touch-zone hidden" id="dragZone">Drag to move</div>
  <div class="touch-buttons hidden" id="touchButtons">
    <div class="touch-btn" id="btnUp">‚ñ≤</div>
    <div class="touch-btn" id="btnDown">‚ñº</div>
  </div>
  <div class="touch-tip" id="touchTip">Mobile: enable controls in Settings</div>
</div>
<script>
(()=>{
  // ====== Canvas ======
  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d');
  function resize(){ cvs.width = innerWidth; cvs.height = innerHeight; }
  addEventListener('resize', resize); resize();
  const W = () => cvs.width, H = () => cvs.height;

  // ====== UI ======
  const $ = id => document.getElementById(id);
  const hud = $('hud'), menu=$('menu'), levelMenu=$('levelMenu'), settingsMenu=$('settingsMenu'), howMenu=$('howMenu'), shopMenu=$('shopMenu');
  const msgEl=$('msg'), lvlEl=$('lvl'), psEl=$('ps'), asEl=$('as'), bcEl=$('bc'), unlockText=$('unlockText'), unlockCoins=$('unlockCoins');
  const coinCount=$('coinCount');
  const playBtn=$('playBtn'), levelBtn=$('levelBtn'), settingsBtn=$('settingsBtn'), howBtn=$('howBtn'), shopBtn=$('shopBtn');
  const shopOpen=$('shopOpen'), lobbyBtn=$('lobbyBtn');
  const backFromLevels=$('backFromLevels'), backFromSettings=$('backFromSettings'), backFromHow=$('backFromHow'), backFromShop=$('backFromShop');
  const fsBtn=$('fsBtn'), wipeBtn=$('wipeBtn');
  const sfxToggle=$('sfxToggle'), flashToggle=$('flashToggle'), particlesToggle=$('particlesToggle');
  const mobileDrag=$('mobileDrag'), mobileButtons=$('mobileButtons');
  const allowGravity=$('allowGravity'), allowGlitch=$('allowGlitch');
  const diffSel=$('diffSel');
  const dragZone=$('dragZone'), touchButtons=$('touchButtons'), btnUp=$('btnUp'), btnDown=$('btnDown'), touchTip=$('touchTip');
  const shopList=$('shopList');
  const btnAbilSlow=$('btnAbilSlow'), btnAbilShield=$('btnAbilShield'), btnAbilPulse=$('btnAbilPulse'), btnAbilFreeze=$('btnAbilFreeze'), btnAbilPortal=$('btnAbilPortal'), btnAbilBand=$('btnAbilBand');

  // ====== Game state ======
  let state='menu';
  let lvl=1; const MAX_LEVEL=400;
  let pScore=0, aScore=0; let highestReached=1; let winStreak=0;

  // ====== Persistence ======
  const store = {
    get k(){ return 'PPONG_SAVE_V10_COINS_400_EXT'; },
    load(){ try{ return JSON.parse(localStorage.getItem(this.k)||'{}'); }catch{ return {}; } },
    save(data){ localStorage.setItem(this.k, JSON.stringify(data)); }
  };
  const save = store.load();
  let highest = Math.max(1, save.highest||1);
  let coins = Math.max(0, save.coins||0);
  let inv = Object.assign({
    // Toggles
    pulse:false, spin:false, dash:false, predict:false, trailPlus:false, coinPlus:false, stability:false, spinMaster:false, netMover:false, ballGlow:false, edgeSaver:false, serveRight:false, capGuard:false, aiDither:false, bandControl:false, wellGuard:false, anglePlus:false,
    // Charges-type unlock flags
    slow:false, shield:false, freezeLaser:false, portalShuffle:false
  }, save.inv||{});
  function persist(){ store.save({ highest, coins, inv, sfx:sfxToggle.checked, flash:flashToggle.checked, particles:particlesToggle.checked, mobileDrag:mobileDrag.checked, mobileButtons:mobileButtons.checked, diff:+diffSel.value, allowGravity:allowGravity.checked, allowGlitch:allowGlitch.checked }); }
  function renderMeta(){ unlockText.textContent = highest; unlockCoins.textContent = coins; coinCount.textContent = coins; }
  renderMeta();

  // ====== Input ======
  const keys = Object.create(null);
  addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(state==='playing' && e.key==='p') togglePause(); });
  addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

  // Mobile controls
  let dragActive=false, dragId=null, dragTargetY=null;
  function updateMobileVisibility(){ const playing=state==='playing'; const showDrag=playing&&mobileDrag.checked; const showBtns=playing&&mobileButtons.checked; dragZone.classList.toggle('hidden', !showDrag); touchButtons.classList.toggle('hidden', !showBtns); dragZone.style.pointerEvents=showDrag?'auto':'none'; touchButtons.style.pointerEvents=showBtns?'auto':'none'; touchTip.classList.toggle('hidden', showDrag||showBtns); }
  dragZone.addEventListener('pointerdown', e=>{ if(dragZone.style.pointerEvents!=='auto') return; dragActive=true; dragId=e.pointerId; dragZone.setPointerCapture(dragId); dragTargetY=e.clientY; });
  dragZone.addEventListener('pointerup', ()=>{ dragActive=false; dragId=null; dragTargetY=null; });
  dragZone.addEventListener('pointermove', e=>{ if(!dragActive) return; dragTargetY=e.clientY; });
  function hold(btn, dir){ let h=null; btn.onpointerdown=()=>{ clearInterval(h); h=setInterval(()=>{ player.y = clamp(player.y + dir*playerSpeed()*0.85*16/1000*60, player.h/2, H()-player.h/2); }, 16); }; btn.onpointerup=btn.onpointerleave=()=> clearInterval(h); }
  hold(btnUp,-1); hold(btnDown,1);

  // Settings init
  sfxToggle.checked=!!save.sfx; flashToggle.checked=save.flash!==false; particlesToggle.checked=save.particles!==false; mobileDrag.checked=save.mobileDrag!==false; mobileButtons.checked=!!save.mobileButtons; allowGravity.checked=!!save.allowGravity; allowGlitch.checked=!!save.allowGlitch; diffSel.value=String(save.diff||0);
  ;[sfxToggle,flashToggle,particlesToggle,mobileDrag,mobileButtons,allowGravity,allowGlitch,diffSel].forEach(el=> el.addEventListener('change', ()=>{ persist(); updateMobileVisibility(); }));
  fsBtn.onclick=()=>{ if(document.fullscreenElement) document.exitFullscreen(); else document.body.requestFullscreen(); };
  wipeBtn.onclick=()=>{ highest=1; coins=0; inv={}; winStreak=0; persist(); renderMeta(); };

  // ====== Game Objects ======
  function paddle(x){ return { x, y:H()/2, w:14, h:Math.max(86, H()*0.16), vy:0, dash:0, prev:[] }; }
  const player = paddle(28);
  const ai = paddle(()=> W()-28);

  function makeBall(speed=7.6, dir=1){ const ang=(Math.random()*Math.PI/2 - Math.PI/4); return { x:W()/2, y:H()/2, r:9, vx:Math.cos(ang)*speed*dir, vy:Math.sin(ang)*speed, cooldown:0, stuck:false, prev:[], type:'normal', age:0, gateCD:0, loopT:0 }; }
  const balls=[makeBall()];

  // Speeds
  function playerSpeed(){ const base=540; const dashMul = (inv.dash && keys['shift']) ? 1.35 : 1; return base * (1 + lvl*0.008) * dashMul; }

  // AI
  let aiThinkTimer=0, aiTargetY=H()/2, aiSpeedBoost=0.015, aiAssist=0;
  function aiParams(){ const diff=+diffSel.value; const ps=playerSpeed(); const followBase=0.06 + lvl*0.001 + diff*0.012 + aiSpeedBoost - aiAssist; const think=Math.max(0.23 - lvl*0.0014 - diff*0.05 + aiAssist*0.5, 0.035); let noise=Math.max(28 - lvl*0.45 - diff*5.5 + aiAssist*8, 3); if(inv.aiDither) noise+=2; const relCap = diff===0?1.35:(diff===1?1.5:1.65); const maxVelBase=460 + lvl*12 + diff*230 + aiSpeedBoost*650; const maxVel=Math.min(maxVelBase, ps*relCap); return { followBase, think, noise, maxVel }; }

  // Rules
  const WIN_POINTS=5;

  // Effects
  const fx={ invert:false, trail:false, warp:false, bulletTime:false, spin:false, sticky:false, glitch:false, gravity:0, windX:0, bandWind:false, conveyor:false, flashes:false, angleFactor:0.34, speedMul:1, randReverse:false, paddleMomentum:false, pulseReflect:false, shieldL:0, shieldR:0, wells:[], bumpers:[], barriers:[], lasers:[], portals:null, collectibles:[], bandY:[], arenaShrink:0, speedGates:[], magnet:false, spinZones:[], illusions:0, blackout:false, movingNet:false, paddleGhost:false, pulseBall:false, windOsc:false, wallTilt:0, lasersFrozenTimer:0, bandFlipTimer:0 };

  // Caps
  const caps={ lasers:3, bumpers:4, wells:4, barriers:3, portals:4, speedGates:4, spinZones:3, balls:3, illusions:2 };
  function clampComplexity(){ fx.lasers.length=Math.min(fx.lasers.length,caps.lasers); fx.bumpers.length=Math.min(fx.bumpers.length,caps.bumpers); fx.wells.length=Math.min(fx.wells.length,caps.wells); fx.barriers.length=Math.min(fx.barriers.length,caps.barriers); if(fx.portals && fx.portals.length>caps.portals) fx.portals=fx.portals.slice(0,caps.portals); fx.speedGates.length=Math.min(fx.speedGates.length,caps.speedGates); fx.spinZones.length=Math.min(fx.spinZones.length,caps.spinZones); if(balls.length>caps.balls) balls.length=caps.balls; fx.illusions=Math.min(fx.illusions,caps.illusions); }

  // Utils
  const clamp=(v,a,b)=>v<a?a:v>b?b:v; const rand=(a,b)=>a+Math.random()*(b-a);
  function reflectCircle(ball,cx,cy){ const dx=ball.x-cx, dy=ball.y-cy; const d=Math.hypot(dx,dy)||1; const nx=dx/d, ny=dy/d; const dot=ball.vx*nx+ball.vy*ny; ball.vx-=2*dot*nx; ball.vy-=2*dot*ny; }

  // Particles
  const parts=[]; function spawnBurst(x,y,n=10){ if(!particlesToggle.checked) return; for(let i=0;i<n;i++) parts.push({x,y,vx:rand(-2,2),vy:rand(-2,2),a:1,r:rand(1,3)}); }

  // Anti-loop near wells
  function antiLoop(b){ if(!allowGravity.checked || !fx.wells.length) return; let near=false; for(const w of fx.wells){ const dx=w.x-b.x, dy=w.y-b.y; const d2=dx*dx+dy*dy; if(d2<w.r*w.r){ near=true; const d=Math.sqrt(d2)||1; const f=(w.strength*(inv.wellGuard?0.8:1))/d2; b.vx += (dx/d)*f; b.vy += (dy/d)*f; } } if(near){ if(Math.abs(b.vy)<0.4) b.loopT=(b.loopT||0)+0.016; else b.loopT=0; if(b.loopT>2.2){ b.vx += (b.x<W()/2?-1:1)*0.8; b.vy += (Math.random()*2-1)*0.8; b.loopT=0; } } else { b.loopT=Math.max(0,(b.loopT||0)-0.05); } }

  // ====== Mechanics pool (no warp edges) ======
  const poolHard=[]; const addH=(name,fn)=>poolHard.push([name,fn]);
  // Existing mechanics
  addH('Afterimage trails', ()=> fx.trail=true);
  addH('Curve bounces (spin)', ()=> fx.spin=true);
  addH('Gravity wells (corners)', ()=> fx.wells=[{x:W()*0.2,y:H()*0.2,strength:16,r:110},{x:W()*0.8,y:H()*0.8,strength:16,r:110}]);
  addH('Center bumper', ()=> fx.bumpers.push({x:W()/2,y:H()/2,r:18}));
  addH('Sweeping laser', ()=> fx.lasers.push({x:W()/2-6,y:H()/2-140,w:12,h:260,vx:2.2,vy:0,on:true,toggle:0,period:1.2}));
  addH('Portals pair', ()=> fx.portals=[{x:W()*0.25,y:H()*0.25,r:22},{x:W()*0.75,y:H()*0.75,r:22}]);
  addH('Band wind', ()=>{ fx.bandWind=true; fx.bandY=[{y0:H()*0.25,y1:H()*0.45,vx:.04},{y0:H()*0.55,y1:H()*0.75,vx:-.04}]; });
  addH('Random reverse on hit', ()=> fx.randReverse=true);
  addH('Conveyor floor', ()=> fx.conveyor=true);
  addH('Ball pulse visual', ()=> fx.pulseBall=true);
  addH('Laser pair line', ()=> fx.lasers.push({x:W()*0.3,y:40,w:W()*0.4,h:10,vx:0,vy:0,on:true,toggle:0,period:0.7}));
  addH('Moving barrier', ()=> fx.barriers.push({x:W()/2-10,y:H()/2-120,w:20,h:220,vx:2,vy:0}));
  addH('One-way portals', ()=> fx.portals=[{x:W()*0.2,y:H()*0.2,r:18,one:1},{x:W()*0.8,y:H()*0.8,r:18,one:-1}]);
  addH('Wall tilt on top/bottom', ()=> fx.wallTilt=0.35);
  addH('More wind', ()=> fx.windX+=0.05);
  addH('Extra ball', ()=> balls.push(makeBall(7.8, Math.random()<0.5?-1:1)));
  addH('Bumper set', ()=>{ fx.bumpers.push({x:W()*0.35,y:H()*0.35,r:14}); fx.bumpers.push({x:W()*0.65,y:H()*0.65,r:14}); });
  addH('Lasers toggle faster', ()=> fx.lasers.forEach(l=> l.period=Math.max(0.35,(l.period||1)*0.8)));
  addH('More wells', ()=> fx.wells.push({x:W()*0.5,y:H()*0.25,strength:14,r:100},{x:W()*0.5,y:H()*0.75,strength:14,r:100}));
  addH('Rotating portals', ()=> portalsRotate=true);
  addH('Split on wall', ()=> splitOnWall=true);
  addH('Heavy balls', ()=> balls.forEach(b=> b.type='heavy'));
  addH('Shrink paddles a bit', ()=>{ player.h*=0.93; ai.h*=0.93; });
  addH('Extra barrier', ()=> fx.barriers.push({x:W()/2-200,y:H()/2-80,w:18,h:160,vx:2.2,vy:0}));
  addH('Spin zones', ()=> fx.spinZones.push({x:W()*0.5,y:H()*0.3,r:60,t:1},{x:W()*0.5,y:H()*0.7,r:60,t:-1}));
  addH('Speed gates', ()=> fx.speedGates.push({x:W()*0.35,y:H()*0.3,w:16,h:140,mul:1.14},{x:W()*0.65,y:H()*0.55,w:16,h:140,mul:1.14}));
  addH('Arena shrink', ()=> fx.arenaShrink=Math.min(70,fx.arenaShrink+35));
  addH('Homing laser', ()=> fx.lasers.push({x:W()-14,y:0,w:8,h:200,vx:0,vy:0,on:true,toggle:0,period:1,homing:true}));
  addH('Edge portals', ()=> fx.portals=[{x:W()*0.1,y:H()*0.5,r:22},{x:W()*0.9,y:H()*0.5,r:22}]);
  addH('Velocity jitter', ()=> velJitter=true);
  // A few more but readable mechanics
  addH('Moving net', ()=> fx.movingNet=true);
  addH('Blackout flicker', ()=> fx.blackout=true);
  addH('Illusion balls', ()=> fx.illusions=Math.min(caps.illusions, fx.illusions+1));
  addH('Wind oscillation', ()=> fx.windOsc=true);
  addH('Paddle ghost visual', ()=> fx.paddleGhost=true);
  addH('Center magnet', ()=> fx.magnet=true);
  addH('Angle steeper', ()=> fx.angleFactor=Math.min(0.46, fx.angleFactor+0.02));

  // ====== Shop items (20) ======
  const shopItems=[
    { id:'pulse', name:'Pulse Reflect', type:'toggle', cost:60, desc:'Space pushes nearby balls.' },
    { id:'slow', name:'Focus Slow √ó2', type:'charges', cost:45, charges:2, desc:'Q slows time for 2.2s.' },
    { id:'shield', name:'Shield √ó1', type:'charges', cost:40, charges:1, desc:'E gives 4s left shield.' },
    { id:'spin', name:'Curve Control', type:'toggle', cost:50, desc:'Slightly stronger curved bounces.' },
    { id:'dash', name:'Dash', type:'toggle', cost:35, desc:'Hold Shift for 35% faster paddle.' },
    { id:'freezeLaser', name:'Freeze Lasers √ó1', type:'charges', cost:35, charges:1, desc:'F freezes lasers for 3s.' },
    { id:'portalShuffle', name:'Shuffle Portals √ó1', type:'charges', cost:30, charges:1, desc:'R randomizes portal positions.' },
    { id:'predict', name:'Predict Line', type:'toggle', cost:30, desc:'Shows a faint predicted ball path.' },
    { id:'trailPlus', name:'Trail+', type:'toggle', cost:20, desc:'Longer ball trail for readability.' },
    { id:'coinPlus', name:'Coin Booster', type:'toggle', cost:70, desc:'+3 coins on level wins.' },
    { id:'stability', name:'Stability', type:'toggle', cost:25, desc:'Halves random reverse and jitter.' },
    { id:'spinMaster', name:'Spin Master', type:'toggle', cost:40, desc:'Adds +0.02 to bounce angle.' },
    { id:'netMover', name:'Moving Net', type:'toggle', cost:15, desc:'Net oscillates visually.' },
    { id:'ballGlow', name:'Ball Glow', type:'toggle', cost:15, desc:'Glow around balls for visibility.' },
    { id:'edgeSaver', name:'Edge Saver √ó1', type:'charges', cost:35, charges:1, desc:'Auto 1.5s shield if ball about to exit left.' },
    { id:'serveRight', name:'Aggro Serve', type:'toggle', cost:10, desc:'Serves toward AI more often.' },
    { id:'capGuard', name:'Speed Guard', type:'toggle', cost:25, desc:'Slightly lowers max ball speed.' },
    { id:'aiDither', name:'AI Dither', type:'toggle', cost:25, desc:'Tiny extra noise in AI tracking.' },
    { id:'bandControl', name:'Wind Flip √ó1', type:'charges', cost:25, charges:1, desc:'B flips wind bands for 4s.' },
    { id:'wellGuard', name:'Well Guard', type:'toggle', cost:20, desc:'20% less gravity pull from wells.' },
  ];

  function buildShop(){ shopList.innerHTML=''; shopItems.forEach(it=>{ const d=document.createElement('div'); d.className='card'; d.style.padding='12px'; const owned = !!inv[it.id]; const action = owned? 'Owned' : `Buy (${it.cost}üü°)`; d.innerHTML = `<div style="font-weight:800;margin-bottom:6px">${it.name}</div><div style="opacity:.8;font-size:12px;margin-bottom:8px">${it.desc}</div><div class="row"><button class="btn" ${owned?'disabled':''}>${action}</button></div>`; const btn=d.querySelector('button'); btn.onclick=()=>{ if(inv[it.id]) return; if(coins<it.cost){ msg('Not enough coins'); return; } coins-=it.cost; inv[it.id]=true; persist(); renderMeta(); buildShop(); msg(`${it.name} purchased`); }; shopList.appendChild(d); }); }

  // ====== Abilities runtime ======
  let abil = { slow:0, shield:0, pulse:false, slowTimer:0, shieldTimer:0, freeze:0, portal:0, band:0, lasersFrozenTimer:0, edgeSaverCt:0, edgeSaverCD:0 };
  function refreshAbilitiesForRound(){
    abil.slow = inv.slow?2:0; abil.shield = inv.shield?1:0; abil.freeze = inv.freezeLaser?1:0; abil.portal = inv.portalShuffle?1:0; abil.band = inv.bandControl?1:0; abil.pulse = inv.pulse || false; abil.edgeSaverCt = inv.edgeSaver?1:0; abil.edgeSaverCD=0;
    if(inv.spin) fx.angleFactor=Math.min(0.42, fx.angleFactor+0.01);
    if(inv.spinMaster) fx.angleFactor=Math.min(0.46, fx.angleFactor+0.02);
    updateAbilHUD();
  }
  function updateAbilHUD(){ $('slowCt').textContent=abil.slow; $('shieldCt').textContent=abil.shield; $('freezeCt').textContent=abil.freeze; $('portalCt').textContent=abil.portal; $('bandCt').textContent=abil.band; btnAbilPulse.style.opacity = (fx.pulseReflect||abil.pulse)?1:0.5; }
  function useSlow(){ if(abil.slow<=0) return; abil.slow--; abil.slowTimer=2.2; msg('Focus slow'); updateAbilHUD(); }
  function useShield(){ if(abil.shield<=0) return; abil.shield--; fx.shieldL=1; abil.shieldTimer=4; msg('Shield up'); updateAbilHUD(); }
  function useFreeze(){ if(abil.freeze<=0) return; abil.freeze--; fx.lasersFrozenTimer=3; msg('Lasers frozen'); updateAbilHUD(); }
  function usePortal(){ if(abil.portal<=0) return; if(fx.portals){ abil.portal--; fx.portals.forEach(p=>{ p.x=rand(W()*0.15,W()*0.85); p.y=rand(H()*0.2,H()*0.8); }); clampComplexity(); msg('Portals shuffled'); updateAbilHUD(); } }
  function useBand(){ if(abil.band<=0) return; if(fx.bandWind){ abil.band--; fx.bandFlipTimer=4; msg('Wind flipped'); updateAbilHUD(); } }

  // ====== Start / Menus ======
  function show(el){ [menu, levelMenu, settingsMenu, howMenu, shopMenu].forEach(e=> e.classList.add('hidden')); el.classList.remove('hidden'); updateMobileVisibility(); }
  playBtn.onclick=()=>{ lvl=1; beginGame(lvl); };
  levelBtn.onclick=()=>{ buildLevelGrid(); show(levelMenu); state='level'; };
  settingsBtn.onclick=()=>{ show(settingsMenu); state='settings'; };
  shopBtn.onclick=shopOpen.onclick=()=>{ buildShop(); show(shopMenu); state='shop'; };
  howBtn.onclick=()=>{ show(howMenu); state='how'; };
  backFromLevels.onclick=backFromSettings.onclick=backFromHow.onclick=backFromShop.onclick=()=>{ show(menu); state='menu'; renderMeta(); };
  lobbyBtn.onclick=()=>{ show(menu); state='menu'; renderMeta(); msg('Back to lobby'); };
  function buildLevelGrid(){ const g=$('levelGrid'); g.innerHTML=''; for(let i=1;i<=MAX_LEVEL;i++){ const d=document.createElement('div'); d.className='btn'; d.textContent=String(i); if(i>highest){ d.style.opacity=.35; d.style.cursor='not-allowed'; } else { d.onclick=()=>{ lvl=i; show(menu); state='menu'; beginGame(lvl); }; } g.appendChild(d); } }

  function clearWorld(){ balls.length=0; balls.push(makeBall()); pScore=0; aScore=0; aiThinkTimer=0; aiTargetY=H()/2; }

  // Level scheduling
  const poolAssist=[]; const addA=(name,fn)=>poolAssist.push([name,fn]);
  addA('Small paddle widen', ()=>{ player.h=Math.min(H()*0.5, player.h*1.07); });
  addA('Pulse reflect unlocked', ()=> fx.pulseReflect=true);
  addA('Left shield (short)', ()=>{ fx.shieldL=1; setTimeout(()=> fx.shieldL=0, 2000); });
  addA('Slight ball slow-down', ()=>{ fx.speedMul*=0.96; });
  addA('AI tiny hesitation', ()=>{ aiAssist+=0.02; });

  let portalsRotate=false, splitOnWall=false, splitOnPaddle=false, velJitter=false, spawnWithSpin=false, baseSpeedMul=1.06;

  const addsByLevel={}; let iH=0,iA=0; for(let L=2; L<=MAX_LEVEL; L++){ const early=L<=60; const addFromHard = early || (L%2===0); if(L%25===0){ addsByLevel[L]=poolAssist[iA % poolAssist.length]; iA++; } else if(addFromHard && iH<poolHard.length){ addsByLevel[L]=poolHard[iH++]; } else { addsByLevel[L]=['Escalation: small ball+AI', ()=>{ baseSpeedMul*=1.014; aiSpeedBoost+=0.009; }]; } }
  function additionLabelForLevel(L){ const a=addsByLevel[L]; return a? a[0] : 'escalation'; }
  function runAdditionForLevel(L){ const a=addsByLevel[L]; if(a){ a[1](); clampComplexity(); } }

  function beginGame(fromLevel){
    clearWorld(); lvl=Math.max(1, Math.min(MAX_LEVEL, fromLevel||1));
    Object.assign(fx,{ invert:false, trail:false, warp:false, bulletTime:false, spin:false, sticky:false, glitch:false, gravity:0, windX:0, bandWind:false, conveyor:false, flashes:false, angleFactor:0.34, speedMul:1, randReverse:false, paddleMomentum:false, pulseReflect:false, shieldL:0, shieldR:0, wells:[], bumpers:[], barriers:[], lasers:[], portals:null, collectibles:[], bandY:[], arenaShrink:0, speedGates:[], magnet:false, spinZones:[], illusions:0, blackout:false, movingNet:false, paddleGhost:false, pulseBall:false, windOsc:false, wallTilt:0, lasersFrozenTimer:0, bandFlipTimer:0 });
    portalsRotate=false; splitOnWall=false; splitOnPaddle=false; velJitter=false; spawnWithSpin=false; baseSpeedMul=1.06; aiSpeedBoost=0.015; aiAssist=0;
    ai.h=Math.max(70,H()*0.16); player.h=Math.max(70,H()*0.16); player.w=14; ai.w=14;

    for(let L=2; L<=lvl; L++) runAdditionForLevel(L);
    if(lvl%25===0) fx.pulseReflect=true;

    refreshAbilitiesForRound();
    hud.style.display='flex'; [menu, levelMenu, settingsMenu, howMenu, shopMenu].forEach(e=> e.classList.add('hidden'));
    state='playing'; updateMobileVisibility(); msgEl.textContent = `Level ${lvl} adds: ${additionLabelForLevel(lvl)} (first to ${WIN_POINTS}).`;
  }

  function togglePause(){ if(state==='playing'){ state='paused'; msgEl.textContent='Paused'; updateMobileVisibility(); } else if(state==='paused'){ state='playing'; msgEl.textContent=`Level ${lvl} adds: ${additionLabelForLevel(lvl)}`; updateMobileVisibility(); } }

  // Ability input
  addEventListener('keydown', e=>{ if(state!=='playing') return; const k=e.key.toLowerCase(); if(k==='q') useSlow(); if(k==='e') useShield(); if(k==='f') useFreeze(); if(k==='r') usePortal(); if(k==='b') useBand(); if(e.code==='Space' && (fx.pulseReflect||abil.pulse)) doPulse(); });
  btnAbilSlow.onclick=()=>{ if(state==='playing') useSlow(); };
  btnAbilShield.onclick=()=>{ if(state==='playing') useShield(); };
  btnAbilFreeze.onclick=()=>{ if(state==='playing') useFreeze(); };
  btnAbilPortal.onclick=()=>{ if(state==='playing') usePortal(); };
  btnAbilBand.onclick=()=>{ if(state==='playing') useBand(); };

  function doPulse(){ for(const b of balls){ const dx=b.x-player.x, dy=b.y-player.y; const d=Math.hypot(dx,dy); if(d<200){ b.vx += (dx/d||1)*2.6; b.vy += (dy/d||1)*2.6; spawnBurst(b.x,b.y,12);} } msg('Pulse!'); }

  function msg(t){ msgEl.textContent=t; }

  // ====== Core update ======
  function update(dt){ if(state!=='playing' && state!=='paused') return; if(state==='paused') return; const nowms=performance.now();
    // Controls
    const up=keys['arrowup']||keys['w']; const down=keys['arrowdown']||keys['s']; let dir=(up?-1:0)+(down?1:0); if(fx.invert) dir*=-1;
    if(dragTargetY!=null){ const dy=clamp(dragTargetY, player.h/2+fx.arenaShrink, H()-player.h/2-fx.arenaShrink) - player.y; const maxStep=playerSpeed()*0.7*dt; if(Math.abs(dy)>maxStep) player.y+=Math.sign(dy)*maxStep; else player.y+=dy; }
    player.vy = dir * playerSpeed(); player.y = clamp(player.y + player.vy*dt, player.h/2+fx.arenaShrink, H()-player.h/2-fx.arenaShrink);
    player.prev.push(player.y); if(player.prev.length>10) player.prev.shift(); ai.prev.push(ai.y); if(ai.prev.length>10) ai.prev.shift();

    // AI
    const ap=aiParams(); aiThinkTimer-=dt; if(aiThinkTimer<=0){ aiThinkTimer=ap.think; const noise=(Math.random()*2-1)*ap.noise; aiTargetY=clamp((balls[0]?.y||H()/2)+noise, ai.h/2+fx.arenaShrink, H()-ai.h/2-fx.arenaShrink); } const dyAI=aiTargetY-ai.y; const step=Math.sign(dyAI)*Math.min(Math.abs(dyAI),(ap.maxVel*ap.followBase)*dt); ai.y=clamp(ai.y+step, ai.h/2+fx.arenaShrink, H()-ai.h/2-fx.arenaShrink);

    // Barriers and lasers
    fx.barriers.forEach(b=>{ b.x+=(b.vx||0); b.y+=(b.vy||0); if(b.x<80||b.x+b.w>W()-80) b.vx*=-1; if(b.y<40+fx.arenaShrink||b.y+b.h>H()-40-fx.arenaShrink) b.vy*=-1; });
    fx.lasers.forEach(l=>{ if(fx.lasersFrozenTimer>0) return; l.toggle=(l.toggle||0)+dt; if(l.toggle>l.period){ l.on=!l.on; l.toggle=0; } if(l.homing){ const targetY=(balls[0]?.y||H()/2)-l.h/2; l.y += (targetY - l.y) * 0.018; } l.x+=l.vx||0; l.y+=l.vy||0; if(l.x<40||l.x+l.w>W()-40) l.vx*=-1; }); if(fx.lasersFrozenTimer>0) fx.lasersFrozenTimer-=dt;
    if(portalsRotate && fx.portals){ const t=nowms/900; fx.portals[0].x=W()*0.25+Math.cos(t)*50; fx.portals[0].y=H()*0.25+Math.sin(t)*50; if(fx.portals[1]){ fx.portals[1].x=W()*0.75+Math.cos(-t)*50; fx.portals[1].y=H()*0.75+Math.sin(-t)*50; } }

    // Wind flip timer
    if(fx.bandFlipTimer>0) fx.bandFlipTimer-=dt;

    const windOsc = fx.windOsc ? Math.sin(nowms/800)*0.06 : 0; const slowMul = abil.slowTimer>0 ? 0.6 : 1; if(abil.slowTimer>0) abil.slowTimer-=dt; if(abil.shieldTimer>0){ abil.shieldTimer-=dt; if(abil.shieldTimer<=0) fx.shieldL=0; }

    for(const b of balls){
      b.age+=dt; if(b.cooldown>0) b.cooldown-=dt; if(b.gateCD>0) b.gateCD-=dt;
      if(fx.bandWind){ for(const band of fx.bandY){ const flip = fx.bandFlipTimer>0?-1:1; if(b.y>band.y0 && b.y<band.y1) b.vx += (band.vx*flip); } }
      b.vx += fx.windX; b.vx += windOsc; if(allowGravity.checked){ b.vy += fx.gravity; }
      if(fx.magnet){ const pull = (W()/2 - b.x) * 0.0002; b.vx += pull; }
      const speedMul = Math.min(2.0, fx.speedMul * baseSpeedMul * (1 + lvl*0.0035)) * slowMul; b.x += b.vx * speedMul; b.y += b.vy * speedMul;

      if(fx.trail){ const max = inv.trailPlus?16:10; b.prev.push([b.x,b.y]); if(b.prev.length>max) b.prev.shift(); }
      if(fx.conveyor){ const f = 0.018; b.vx += Math.sin(b.y/120)*f; }
      if(allowGlitch.checked && fx.glitch && Math.random()<0.0006){ b.vx*=-1; b.vy+=rand(-0.8,0.8); }

      const topB=fx.arenaShrink, botB=H()-fx.arenaShrink;
      if(b.y - b.r < topB){ b.y=topB+b.r; b.vy*=-1; if(fx.wallTilt){ const s=b.vx>=0?1:-1; b.vx += s*fx.wallTilt; } hitShake(); if(splitOnWall) trySplit(b); }
      if(b.y + b.r > botB){ b.y=botB-b.r; b.vy*=-1; if(fx.wallTilt){ const s=b.vx>=0?1:-1; b.vx += s*fx.wallTilt; } hitShake(); if(splitOnWall) trySplit(b); }

      if(abil.edgeSaverCt>0 && abil.edgeSaverCD<=0 && b.x<34 && b.vx<0){ fx.shieldL=1; abil.edgeSaverCt--; abil.edgeSaverTimer=1.5; abil.edgeSaverCD=5; msg('Edge Saver'); }
      if(abil.edgeSaverTimer>0){ abil.edgeSaverTimer-=dt; if(abil.edgeSaverTimer<=0) fx.shieldL=0; }
      if(abil.edgeSaverCD>0) abil.edgeSaverCD-=dt;

      if(fx.shieldL){ const sx=60,w=8,y=H()/2-100,h=200; if(rectHit(b,sx,y,w,h)){ b.x=sx+w+b.r; b.vx=Math.abs(b.vx); spawnBurst(b.x,b.y,6); } }
      if(fx.shieldR){ const sx=W()-68,w=8,y=H()/2-100,h=200; if(rectHit(b,sx,y,w,h)){ b.x=sx-b.r; b.vx=-Math.abs(b.vx); spawnBurst(b.x,b.y,6); } }

      for(const r of fx.barriers){ if(rectHit(b,r.x,r.y,r.w,r.h)) bounceRect(b,r); }
      for(const p of fx.bumpers){ const dx=b.x-p.x, dy=b.y-p.y; if(p.vx){ p.x+=p.vx; if(p.x-p.r<80||p.x+p.r>W()-80) p.vx*=-1; } const d=Math.hypot(dx,dy); if(d<b.r+p.r){ reflectCircle(b,p.x,p.y); b.x += (dx/(d||1))*(b.r+p.r-d); b.y += (dy/(d||1))*(b.r+p.r-d); hitShake(); } }
      for(const w of fx.wells){ const dx=w.x-b.x, dy=w.y-b.y; const d2=dx*dx+dy*dy; if(d2<w.r*w.r){ const d=Math.sqrt(d2)||1; const f=w.strength/d2; b.vx += (dx/d)*f; b.vy += (dy/d)*f; } }
      for(const l of fx.lasers){ if(!l.on) continue; if(rectHit(b,l.x,l.y,l.w,l.h)){ b.vx*=-1; b.vy+=rand(-0.8,0.8); spawnBurst(b.x,b.y,10); hitShake(); } }
      for(const g of fx.speedGates){ if(rectHit(b,g.x,g.y,g.w,g.h) && b.gateCD<=0){ b.vx*=g.mul; b.vy*=g.mul; b.gateCD=0.25; spawnBurst(b.x,b.y,6); } }

      if(fx.portals && fx.portals.length>=2){ for(let i=0;i<fx.portals.length;i++){ const A=fx.portals[i]; if(circleHit(b,A) && b.cooldown<=0 && (!A.one || Math.sign(b.vx)===A.one)){ const j=(i+1)%fx.portals.length; const B=fx.portals[j]; b.x=B.x; b.y=B.y; b.cooldown=.25; hitShake(); break; } } }

      const leftHit=collidePaddle(b,'left',player); const rightHit=collidePaddle(b,'right',ai); if(splitOnPaddle && (leftHit||rightHit)) trySplit(b);

      if(b.x + b.r < 0){ if(award('ai')) return; resetBall(b,-1); }
      if(b.x - b.r > W()){ if(award('player')) return; resetBall(b,1); }

      antiLoop(b);
      clampBallSpeed(b);
      if(velJitter){ const j = inv.stability?0.008:0.015; b.vx += rand(-j,j); b.vy += rand(-j,j); }
    }

    for(let i=parts.length-1;i>=0;i--){ const p=parts[i]; p.x+=p.vx; p.y+=p.vy; p.a-=0.02; if(p.a<=0) parts.splice(i,1); }

    lvlEl.textContent=lvl; psEl.textContent=pScore; asEl.textContent=aScore; bcEl.textContent=balls.length; renderMeta();
    if(highestReached>highest){ highest=highestReached; persist(); }
  }

  function clampBallSpeed(b){ const ps=playerSpeed(); const diff=+diffSel.value; let capMul = (diff===0?1.45:diff===1?1.55:1.65); if(inv.capGuard) capMul*=0.92; const cap = capMul * (ps/60); const s = Math.hypot(b.vx,b.vy); if(s>cap){ const scale=cap/s; b.vx*=scale; b.vy*=scale; } }

  function award(side){ if(side==='player') pScore++; else aScore++; if(pScore>=WIN_POINTS){ const bonus = inv.coinPlus?3:0; coins += 5 + Math.floor(lvl/10) + bonus; winStreak++; persist(); advanceLevel(); return true; } if(aScore>=WIN_POINTS){ winStreak=0; failRound(); return true; } return false; }

  function advanceLevel(){ lvl=Math.min(MAX_LEVEL, lvl+1); highestReached=Math.max(highestReached,lvl); runAdditionForLevel(lvl); const label=additionLabelForLevel(lvl); clearWorld(); msg(`Level up ‚Üí ${lvl} adds: ${label}. +Coins`); refreshAbilitiesForRound(); }
  function failRound(){ msg('Round lost. Try again.'); clearWorld(); refreshAbilitiesForRound(); }

  function trySplit(b){ if(balls.length<caps.balls){ const nb=makeBall(Math.hypot(b.vx,b.vy), Math.sign(-b.vx)||1); nb.x=b.x; nb.y=b.y; nb.vx=-b.vx*0.9; nb.vy=b.vy*0.9; balls.push(nb); } }
  function rectHit(b,x,y,w,h){ return b.x + b.r > x && b.x - b.r < x+w && b.y + b.r > y && b.y - b.r < y+h; }
  function circleHit(b,c){ const dx=b.x-c.x, dy=b.y-c.y; return dx*dx+dy*dy < (b.r+c.r)*(b.r+c.r); }
  function bounceRect(b,r){ const leftPen=Math.abs(r.x - (b.x + b.r)); const rightPen=Math.abs((r.x + r.w) - (b.x - b.r)); if(leftPen<rightPen){ b.x=r.x - b.r; b.vx=-Math.abs(b.vx); } else { b.x=r.x + r.w + b.r; b.vx=Math.abs(b.vx); } hitShake(); }
  function collidePaddle(b,side,pad){ const px=typeof pad.x==='function'?pad.x():pad.x; const py=pad.y; const pw=pad.w, ph=pad.h; const rx=px-pw/2, ry=py-ph/2; if(rectHit(b,rx,ry,pw,ph)){
      const center=py; const off=(b.y-center)/(ph/2); const ang=clamp(off,-1,1)*fx.angleFactor*Math.PI/2; const sp=Math.max(6, Math.hypot(b.vx,b.vy)); const dir=side==='left'?1:-1;
      b.vx=Math.cos(ang)*sp*dir; b.vy=Math.sin(ang)*sp; if(fx.spin) b.vy += pad.vy*0.05; if(fx.randReverse && Math.random()<(inv.stability?0.015:0.03)) b.vx*=-1; if(fx.sticky){ b.stuck=true; setTimeout(()=> b.stuck=false,160); } spawnBurst(b.x,b.y,8); hitShake(); return true; } return false; }
  function resetBall(b,dir){ const preferRight = inv.serveRight? (Math.random()<0.75?1:dir) : dir; b.x=W()/2; b.y=H()/2; const speed=7.6 + lvl*0.07; const ang=(Math.random()*Math.PI/2 - Math.PI/4); b.vx=Math.cos(ang)*speed*preferRight; b.vy=Math.sin(ang)*speed; b.prev.length=0; if(spawnWithSpin){ b.vy += rand(-0.8,0.8); } }
  let shakeT=0; function hitShake(){ shakeT=0.08; }

  // ====== Draw ======
  function draw(){ ctx.fillStyle='#080808'; ctx.fillRect(0,0,W(),H()); if(fx.arenaShrink>0){ ctx.fillStyle='#111'; ctx.fillRect(0,0,W(),fx.arenaShrink); ctx.fillRect(0,H()-fx.arenaShrink,W(),fx.arenaShrink); }
    ctx.save(); if(shakeT>0){ ctx.translate((Math.random()-.5)*10*shakeT*6,(Math.random()-.5)*10*shakeT*6); shakeT=Math.max(0,shakeT-0.02); }
    const netOffset = (fx.movingNet||inv.netMover) ? Math.sin(performance.now()/700)*26 : 0; ctx.fillStyle='#ddd'; for(let y=0;y<H();y+=24) ctx.fillRect(W()/2-2+netOffset,y,4,14);
    if(fx.shieldL){ ctx.fillStyle='#2af'; ctx.fillRect(60, H()/2-100, 8, 200); }
    if(fx.shieldR){ ctx.fillStyle='#2af'; ctx.fillRect(W()-68, H()/2-100, 8, 200); }
    ctx.fillStyle='#3af'; fx.barriers.forEach(r=> ctx.fillRect(r.x,r.y,r.w,r.h));
    ctx.fillStyle='#f33'; fx.lasers.forEach(l=>{ if(l.on) ctx.fillRect(l.x,l.y,l.w,l.h); });
    ctx.fillStyle='#f47'; fx.bumpers.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); });
    ctx.strokeStyle='#6f6'; ctx.lineWidth=2; fx.spinZones.forEach(sz=>{ ctx.beginPath(); ctx.arc(sz.x,sz.y,sz.r,0,Math.PI*2); ctx.stroke(); });
    ctx.fillStyle='#49f'; fx.speedGates.forEach(g=> ctx.fillRect(g.x,g.y,g.w,g.h));
    if(fx.portals){ ctx.strokeStyle='#9f9'; ctx.lineWidth=3; fx.portals.forEach(P=>{ ctx.beginPath(); ctx.arc(P.x,P.y,P.r,0,Math.PI*2); ctx.stroke(); }); }

    ctx.fillStyle='#fff';
    if(fx.paddleGhost){ ctx.globalAlpha=0.2; for(const py of player.prev){ ctx.fillRect(player.x-player.w/2, py-player.h/2, player.w, player.h); } ctx.globalAlpha=1; }
    ctx.fillRect(player.x-player.w/2, player.y-player.h/2, player.w, player.h);
    const aix=typeof ai.x==='function'? ai.x(): ai.x; ctx.fillRect(aix-ai.w/2, ai.y-ai.h/2, ai.w, ai.h);

    for(const b of balls){ if(fx.trail && b.prev.length>1){ ctx.globalAlpha=0.12; for(const [x,y] of b.prev){ ctx.beginPath(); ctx.arc(x,y,Math.max(2,b.r-3),0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); } ctx.globalAlpha=1; }
      if(inv.ballGlow){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r+3,0,Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=3; ctx.stroke(); }
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); }

    if(fx.illusions>0 && balls[0]){ for(let i=1;i<=fx.illusions;i++){ const b=balls[0]; const phase=i*0.6; const ix=b.x + Math.cos(performance.now()/400+phase)*30; const iy=b.y + Math.sin(performance.now()/400+phase)*30; ctx.globalAlpha=0.22; ctx.beginPath(); ctx.arc(ix,iy,b.r,0,Math.PI*2); ctx.fillStyle='#aaa'; ctx.fill(); ctx.globalAlpha=1; } }

    if(inv.predict && balls[0]){ ctx.globalAlpha=0.25; ctx.strokeStyle='#fff'; ctx.beginPath(); const p = predictPath(balls[0]); ctx.moveTo(p[0][0],p[0][1]); for(let i=1;i<p.length;i++){ ctx.lineTo(p[i][0],p[i][1]); } ctx.stroke(); ctx.globalAlpha=1; }

    ctx.restore(); if(fx.blackout){ const on=Math.sin(performance.now()/700) > 0.75; if(on){ ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W(),H()); } }
  }

  function predictPath(b){ const pts=[[b.x,b.y]]; let x=b.x,y=b.y,vx=b.vx,vy=b.vy; const topB=fx.arenaShrink, botB=H()-fx.arenaShrink; const steps=140; for(let i=0;i<steps;i++){ x+=vx*0.8; y+=vy*0.8; if(y - b.r < topB){ y=topB+b.r; vy*=-1; } if(y + b.r > botB){ y=botB-b.r; vy*=-1; } if(x<0||x>W()){ pts.push([x,y]); break; } if(i%6===0) pts.push([x,y]); } return pts; }

  // ====== Loop ======
  let last=performance.now(); function frame(now){ const dt=Math.min(0.05,(now-last)/1000); last=now; update(dt); draw(); requestAnimationFrame(frame); } requestAnimationFrame(frame);

  // ====== Self-tests ======
  (function selfTests(){ try{ console.assert(typeof aiParams()==='object' && aiParams()!==null, 'aiParams returns object'); console.assert(lvl===1,'Initial level is 1'); console.assert(state==='menu','Initial state is menu'); const lasersBak=fx.lasers.slice(); fx.lasers=[{},{},{},{},{}]; clampComplexity(); console.assert(fx.lasers.length<=3,'Laser cap enforced'); fx.lasers=lasersBak; const cap=aiParams(); console.assert(cap.maxVel <= playerSpeed()*1.65,'AI speed cap'); console.assert(MAX_LEVEL===400,'400 levels'); console.assert(shopItems.length===20,'20 shop items'); console.log('Self-tests passed'); }catch(e){ console.warn('Self-tests failed', e); } })();

  function init(){ renderMeta(); buildShop(); show(menu); state='menu'; updateMobileVisibility(); }
  init();
})();
</script>
</body>
</html>
